# Setting Up a Simple API

- In this particular chapter, we will be working on making a Simple API for our project.
- We will be working with "Django REST Framework", it's a toolkit/library built-on top of django that makes building API very easy.
- But, before we start making API with `djangorestframework`, we will use manual methods to make a Simple API.
- For, this purpose move to the folder where `manage.py` is located, and create a folder called `api`. And, we do it using the command `python3 manage.py startapp api`. And edit them as follows:

    `views.py` - `api` app

    ```python
    from django.shortcuts import render
    from django.http import JsonResponse

    # Create your views here.

    def getRoutes(request):
        routes = [
            {'GET':'/api/projects'},
            {'GET':'/api/projects/id'},
            
            {'POST':'/api/projects/id/vote'},
            {'POST':'/api/users/token'},
            {'POST':'/api/users/token/refresh'},
        ]
        return JsonResponse(routes, safe=False)
    ```

    Here, we have `safe=False` so that we can return something here more than python dictionary. By default, JsonResponse can only return a dictionary, because we are sending a list, we set `safe=False`.

    Similarly, create a `urls.py`.

    `urls.py` - `api` app

    ```python
    from django.urls import path
    from . import views

    urlpatterns = [
        path('',views.getRoutes)
    ]
    ```

    Once, you are done with this move to the `urls.py` in the project folder, in our case `test-project` folder, as we need to let it know about this api app.

    `urls.py` - `test-project`

    ```python
    """test_project URL Configuration

    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/4.1/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include

    from django.conf import settings
    # üëÜüèª we want to have access to the setting.py file over here, because we have to connect to our media route and media url.
    from django.conf.urls.static import static
    # üëÜüèª So, we are importing static, which help us create urls for our static
    from django.contrib.auth import views as auth_views

    urlpatterns = [
        path("admin/", admin.site.urls),
        path("",include("projects.urls")),
        path("users/",include("users.urls")),
        path("api/",include("api.urls")), 
        # Here we are importing the paths from the projects app that we created, there in we have a file urls.py which has the urls to the views.

        path('reset_password/',auth_views.PasswordResetView.as_view(template_name="reset_password.html"),name="reset_password"),
        path('reset_password_sent/',auth_views.PasswordResetDoneView.as_view(template_name="reset_password_sent.html"),name="password_reset_done"),
        path('reset/<uidb64>/<token>/',auth_views.PasswordResetConfirmView.as_view(template_name="reset.html"),name="password_reset_confirm"),
        path('reset_password_complete/',auth_views.PasswordResetCompleteView.as_view(template_name="reset_password_complete.html"),name="password_reset_complete"),
    ]

    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
    urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)

    ```

    Once, done we can go ahead, and test this out. And, this what you would see:

    ![](/imgs/Screenshot%202023-10-05%20at%202.52.19‚ÄØAM.png)

    It's not really an API at this point, but we will work on it later.

# Django REST Framework and Serializers

- Now, we need to get started by adding the `rest_framework` to our `INSTALLED_APPS`.

    `settings.py` - `test_project`

    ```python
    """
    Django settings for test_project project.

    Generated by 'django-admin startproject' using Django 4.1.7.

    For more information on this file, see
    https://docs.djangoproject.com/en/4.1/topics/settings/

    For the full list of settings and their values, see
    https://docs.djangoproject.com/en/4.1/ref/settings/
    """

    from pathlib import Path
    import os

    # Build paths inside the project like this: BASE_DIR / 'subdir'.
    BASE_DIR = Path(__file__).resolve().parent.parent


    # Quick-start development settings - unsuitable for production
    # See https://docs.djangoproject.com/en/4.1/howto/deployment/checklist/

    # SECURITY WARNING: keep the secret key used in production secret!
    SECRET_KEY = "django-insecure-j%6$9q#pw3cyqpsh=*lwpg6s-l23-)gk1wz3h-hbyk!muaivr_"

    # SECURITY WARNING: don't run with debug turned on in production!
    DEBUG = True

    ALLOWED_HOSTS = ['localhost','127.0.0.1']


    # Application definition

    INSTALLED_APPS = [
        "django.contrib.admin",
        "django.contrib.auth",
        "django.contrib.contenttypes",
        "django.contrib.sessions",
        "django.contrib.messages",
        "django.contrib.staticfiles",
        
        "projects.apps.ProjectsConfig",
        "users.apps.UsersConfig",
        'fontawesomefree',
        
        'rest_framework',
    ]

    MIDDLEWARE = [
        "django.middleware.security.SecurityMiddleware",
        "django.contrib.sessions.middleware.SessionMiddleware",
        "django.middleware.common.CommonMiddleware",
        "django.middleware.csrf.CsrfViewMiddleware",
        "django.contrib.auth.middleware.AuthenticationMiddleware",
        "django.contrib.messages.middleware.MessageMiddleware",
        "django.middleware.clickjacking.XFrameOptionsMiddleware",
        "whitenoise.middleware.WhiteNoiseMiddleware", # Added by user.
    ]

    ROOT_URLCONF = "test_project.urls"

    TEMPLATES = [
        {
            "BACKEND": "django.template.backends.django.DjangoTemplates",
            "DIRS": [
                os.path.join(BASE_DIR,"templates"), # This let's Django know where our templates are.
            ],
            "APP_DIRS": True,
            "OPTIONS": {
                "context_processors": [
                    "django.template.context_processors.debug",
                    "django.template.context_processors.request",
                    "django.contrib.auth.context_processors.auth",
                    "django.contrib.messages.context_processors.messages",
                ],
            },
        },
    ]

    WSGI_APPLICATION = "test_project.wsgi.application"


    # Database
    # https://docs.djangoproject.com/en/4.1/ref/settings/#databases

    DATABASES = {
        "default": {
            "ENGINE": "django.db.backends.sqlite3",
            "NAME": BASE_DIR / "db.sqlite3",
        }
    }


    # Password validation
    # https://docs.djangoproject.com/en/4.1/ref/settings/#auth-password-validators

    AUTH_PASSWORD_VALIDATORS = [
        {
            "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
        },
        {
            "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
        },
        {
            "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
        },
        {
            "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
        },
    ]


    # Internationalization
    # https://docs.djangoproject.com/en/4.1/topics/i18n/

    LANGUAGE_CODE = "en-us"

    TIME_ZONE = "UTC"

    USE_I18N = True

    USE_TZ = True

    EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
    EMAIL_HOST = 'smtp.gmail.com'
    EMAIL_PORT = 587 # You can find it by googling "gmail PORT"
    EMAIL_USE_TLS = True
    EMAIL_HOST_USER = 'djangoproject296@gmail.com'
    EMAIL_HOST_PASSWORD = 'lityopearxagdlvw'

    # Static files (CSS, JavaScript, Images)
    # https://docs.djangoproject.com/en/4.1/howto/static-files/

    STATIC_URL = "/static/"
    MEDIA_URL = "/images/"

    STATICFILES_DIRS = [
        BASE_DIR / 'static'
    ]

    MEDIA_ROOT = os.path.join(BASE_DIR,"static/images")
    STATIC_ROOT = os.path.join(BASE_DIR,"staticfiles")

    # Default primary key field type
    # https://docs.djangoproject.com/en/4.1/ref/settings/#default-auto-field

    DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"
    ```

    Next we wanna do is modify our `api` view. Cause once we are done customising these views, we will have access to something called `request.data`. This is a different way of getting the data from any POST request we send.

    If we are using a function based view, we are gonna use a decorator, we will be turning it into a rest framework view `@api_view`. If it's a class-based view, we will add `APIView`. So, the documentation gives both the option till date of October, 2023.

    So, what we wanna do is import the api view decorator, and than we need to wrap any view that we have using the decorators. The Decorators are simply gonna tell us what of Request method can be sent to this view, and than we use the response method.

    `views.py` - `api`

    ```python
    from django.shortcuts import render
    from django.http import JsonResponse
    from rest_framework.decorators import api_view
    from rest_framework.response import Response

    # Create your views here.

    @api_view(['GET'])
    def getRoutes(request):
        routes = [
            {'GET':'/api/projects'},
            {'GET':'/api/projects/id'},
            
            {'POST':'/api/projects/id/vote'},
            {'POST':'/api/users/token'},
            {'POST':'/api/users/token/refresh'},
        ]
        return Response(routes)
    ```

    And, this is what we see now.

    ![](/imgs/Screenshot%202023-10-05%20at%204.35.14‚ÄØAM.png)

    In this case, because we are returning a list of python objects, we are gonna need to serailize this information. Serialization is nothing but process of converting our data here. So, we will create a Serializer, and specify the model we want to serialize, the fields we want to output.

    `serializers.py` - `api`

    ```python
    from rest_framework import serializers
    from projects.models import Project

    class ProjectSerializer(serializers.ModelSerializer):
        class Meta:
            model = Project
            fields = '__all__'
    ```

    `views.py` - `api`

    ```python
    from django.shortcuts import render
    from django.http import JsonResponse
    from rest_framework.decorators import api_view
    from rest_framework.response import Response
    from projects.models import Project
    from .serializers import ProjectSerializer

    # Create your views here.

    @api_view(['GET'])
    def getRoutes(request):
        routes = [
            {'GET':'/api/projects'},
            {'GET':'/api/projects/id'},
            
            {'POST':'/api/projects/id/vote'},
            {'POST':'/api/users/token'},
            {'POST':'/api/users/token/refresh'},
        ]
        return Response(routes)

    @api_view(['GET'])
    def getProjects(request):
        projects = Project.objects.all()
        serializer = ProjectSerializer(projects, many=True)
        return Response(serializer.data)

    @api_view(['GET'])
    def getProject(request,pk):
        project = Project.objects.get(id=pk)
        serializer = ProjectSerializer(project, many=False)
        return Response(serializer.data)
    ```

    `urls.py` - `api`

    ```python
    from django.urls import path
    from . import views

    urlpatterns = [
        path('',views.getRoutes),
        path('projects/',views.getProjects),
        path('project/<str:pk>',views.getProject),
    ]
    ```

    And, now we can see all our data in serializaed format. Here is the projects api:

    ![](/imgs/Screenshot%202023-10-05%20at%204.57.21‚ÄØAM.png)

    Here is the project api for a specific project:

    ![](/imgs/Screenshot%202023-10-05%20at%205.01.36‚ÄØAM.png)

# Nested Serializers and Serializer Method

- Right now we want to work on serializer relationships and serializer method fields. So, if you look carefully to the `GET Project` page above, we are only getting the owner ID, rather we want the owner object nested. For the tags, we don't want to get the tag IDs, we wish to be able to access the tag objects. So, let's move to `serializers.py` file.

    `serializers.py` - `api` app

    ```python
    from rest_framework import serializers
    from projects.models import Project, Tag
    from users.models import Profile

    class ProfileSerailizer(serializers.ModelSerializer):
        class Meta:
            model = Profile
            fields = '__all__'

    class TagSerailizer(serializers.ModelSerializer):
        class Meta:
            model = Tag
            fields = '__all__'


    class ProjectSerializer(serializers.ModelSerializer):
        owner = ProfileSerailizer(many=False)
        class Meta:
            model = Project
            fields = '__all__'
    ```

    Once, we have done this. What happens is now we get the complete owner object associated with that project. And, now we can actually nest relationships.

    ![](/imgs/Screenshot%202023-10-06%20at%204.32.32‚ÄØAM.png)

    And, similary for the tags:

    `serializers.py` - `api` app

    ```python
    from rest_framework import serializers
    from projects.models import Project, Tag
    from users.models import Profile

    class ProfileSerailizer(serializers.ModelSerializer):
        class Meta:
            model = Profile
            fields = '__all__'

    class TagSerailizer(serializers.ModelSerializer):
        class Meta:
            model = Tag
            fields = '__all__'


    class ProjectSerializer(serializers.ModelSerializer):
        owner = ProfileSerailizer(many=False)
        tags = TagSerailizer(many=True)
        class Meta:
            model = Project
            fields = '__all__'
    ```

    And, now if you refresh you will see the tag objects as well.

    ![](/imgs/Screenshot%202023-10-06%20at%204.37.11‚ÄØAM.png)

    Right now, we can't see reviews here as they are a child element. So, we need to make use of something called Nested Serializer and Serializer Method.

    `serializers.py` - `api` app

    ```python
    from rest_framework import serializers
    from projects.models import Project, Tag, Review
    from users.models import Profile

    class ProfileSerailizer(serializers.ModelSerializer):
        class Meta:
            model = Profile
            fields = '__all__'

    class TagSerailizer(serializers.ModelSerializer):
        class Meta:
            model = Tag
            fields = '__all__'

    class ReviewSerailizer(serializers.ModelSerializer):
        class Meta:
            model = Review
            fields = '__all__'


    class ProjectSerializer(serializers.ModelSerializer):
        owner = ProfileSerailizer(many=False)
        tags = TagSerailizer(many=True)
        reviews = serializers.SerializerMethodField()
        class Meta:
            model = Project
            fields = '__all__'

        def get_reviews(self, obj):
            reviews = obj.review_set.all()
            serializer = ReviewSerailizer(reviews, many=True)
            return serializer.data
    ```

    And, now if you check it out, here we see review object associated with the project clearly visible.

    ![](/imgs/Screenshot%202023-10-06%20at%204.47.19‚ÄØAM.png)

# Setting up Postman

- In order, to get started working with our POST Requests, and testing out the APIs, it's better to start setting up postman for our project.

- So, we have created a New Collection by the name of `DevSearch`. And, set some of the basic `Variable`s, as follows:

    ![](/imgs/Screenshot%202023-10-06%20at%205.19.25‚ÄØAM.png)

- We can fetch all the projects as:

    ![](/imgs/Screenshot%202023-10-06%20at%205.21.07‚ÄØAM.png)

- If we want to fetch a specific project, do it as:

    ![](/imgs/Screenshot%202023-10-06%20at%205.22.06‚ÄØAM.png)


# Authentication with JSON Web Tokens

- Django by-default uses Session based authentication. So, if we inspect our website, and see here, in cookies, we will see a `sessionid`. On login, django creates a `sessionid` in database. We have an entire database folder for sessionids.

![](/imgs/Screenshot%202023-10-06%20at%205.43.25‚ÄØAM.png)

- On every single request, this `sessionid` is retrieved by the backend, and we ever hit an endpoint that's supposed to be restricted only to logged in users, django will check this id and make sure that the user is allowed to be there.

- Now for APIs, they are completely different. We could use session base authentication, but we will use JSON Web tokens. And the reasons why we are going to use them:

  - Depending on how you setup your API, where our API and our backend, or your server or your frontend are completely seprate applications. So, e may have one hosted on one server and one on the another, and because they are completely seprate, we need a token to pass along b/w 2 apllications.

- A JSON Web Token is simply an encrypted piece of information about the user. For this we start with installing `djangorestframework-simplejwt`. Once done, move to `settings.py` in `project` folder. And, make the following changes:

    Add this piece of code above `MIDDLEWARE`:

    ```python
    REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    )
    }
    ```

    `settings.py` - `test_project` - `project` folder

    ```python
    """
    Django settings for test_project project.

    Generated by 'django-admin startproject' using Django 4.1.7.

    For more information on this file, see
    https://docs.djangoproject.com/en/4.1/topics/settings/

    For the full list of settings and their values, see
    https://docs.djangoproject.com/en/4.1/ref/settings/
    """

    from pathlib import Path
    import os

    # Build paths inside the project like this: BASE_DIR / 'subdir'.
    BASE_DIR = Path(__file__).resolve().parent.parent


    # Quick-start development settings - unsuitable for production
    # See https://docs.djangoproject.com/en/4.1/howto/deployment/checklist/

    # SECURITY WARNING: keep the secret key used in production secret!
    SECRET_KEY = "django-insecure-j%6$9q#pw3cyqpsh=*lwpg6s-l23-)gk1wz3h-hbyk!muaivr_"

    # SECURITY WARNING: don't run with debug turned on in production!
    DEBUG = True

    ALLOWED_HOSTS = ['localhost','127.0.0.1']


    # Application definition

    INSTALLED_APPS = [
        "django.contrib.admin",
        "django.contrib.auth",
        "django.contrib.contenttypes",
        "django.contrib.sessions",
        "django.contrib.messages",
        "django.contrib.staticfiles",
        
        "projects.apps.ProjectsConfig",
        "users.apps.UsersConfig",
        'fontawesomefree',
        
        'rest_framework',
    ]

    REST_FRAMEWORK = {
        'DEFAULT_AUTHENTICATION_CLASSES': (
            'rest_framework_simplejwt.authentication.JWTAuthentication',
        )
    }

    MIDDLEWARE = [
        "django.middleware.security.SecurityMiddleware",
        "django.contrib.sessions.middleware.SessionMiddleware",
        "django.middleware.common.CommonMiddleware",
        "django.middleware.csrf.CsrfViewMiddleware",
        "django.contrib.auth.middleware.AuthenticationMiddleware",
        "django.contrib.messages.middleware.MessageMiddleware",
        "django.middleware.clickjacking.XFrameOptionsMiddleware",
        "whitenoise.middleware.WhiteNoiseMiddleware", # Added by user.
    ]

    ROOT_URLCONF = "test_project.urls"

    TEMPLATES = [
        {
            "BACKEND": "django.template.backends.django.DjangoTemplates",
            "DIRS": [
                os.path.join(BASE_DIR,"templates"), # This let's Django know where our templates are.
            ],
            "APP_DIRS": True,
            "OPTIONS": {
                "context_processors": [
                    "django.template.context_processors.debug",
                    "django.template.context_processors.request",
                    "django.contrib.auth.context_processors.auth",
                    "django.contrib.messages.context_processors.messages",
                ],
            },
        },
    ]

    WSGI_APPLICATION = "test_project.wsgi.application"


    # Database
    # https://docs.djangoproject.com/en/4.1/ref/settings/#databases

    DATABASES = {
        "default": {
            "ENGINE": "django.db.backends.sqlite3",
            "NAME": BASE_DIR / "db.sqlite3",
        }
    }


    # Password validation
    # https://docs.djangoproject.com/en/4.1/ref/settings/#auth-password-validators

    AUTH_PASSWORD_VALIDATORS = [
        {
            "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
        },
        {
            "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
        },
        {
            "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
        },
        {
            "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
        },
    ]


    # Internationalization
    # https://docs.djangoproject.com/en/4.1/topics/i18n/

    LANGUAGE_CODE = "en-us"

    TIME_ZONE = "UTC"

    USE_I18N = True

    USE_TZ = True

    EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
    EMAIL_HOST = 'smtp.gmail.com'
    EMAIL_PORT = 587 # You can find it by googling "gmail PORT"
    EMAIL_USE_TLS = True
    EMAIL_HOST_USER = 'djangoproject296@gmail.com'
    EMAIL_HOST_PASSWORD = 'lityopearxagdlvw'

    # Static files (CSS, JavaScript, Images)
    # https://docs.djangoproject.com/en/4.1/howto/static-files/

    STATIC_URL = "/static/"
    MEDIA_URL = "/images/"

    STATICFILES_DIRS = [
        BASE_DIR / 'static'
    ]

    MEDIA_ROOT = os.path.join(BASE_DIR,"static/images")
    STATIC_ROOT = os.path.join(BASE_DIR,"staticfiles")

    # Default primary key field type
    # https://docs.djangoproject.com/en/4.1/ref/settings/#default-auto-field

    DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"
    ```

- Now, move to the `api` app, and make the following changes to `urls.py`.

    `urls.py` - `api` app

    ```python
    from django.urls import path
    from . import views
    from rest_framework_simplejwt.views import (
        TokenObtainPairView,
        TokenRefreshView,
    )

    urlpatterns = [
        path('users/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'),
        path('users/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
        
        path('',views.getRoutes),
        path('projects/',views.getProjects),
        path('project/<str:pk>',views.getProject),
    ]

    ```

    `TokenObtainPairView` is to generate a token based on the user. So, what's gonna happen is when we hit this endpoint, and we submit our username and password, it will generate a JSON Webtoken for us.

    `TokenRefreshView` will give us a token to generate a new token. A token is going to be stored in the browser somewhere, typically have a shorter life-span of 5 mins. So, someone doesn't hack our website or something like that the webtoken expires. The Refresh Token has a longer life-span.

    On entering my Username, and Passowrd, we get a `refresh` token and, an `access` token. So, if we copy the `access` token and paste in on `jwt.io` we get a lot of details about encryption and all.

    ![](/imgs/Screenshot%202023-10-06%20at%207.33.26‚ÄØAM.png)

    So, now let's make a POST Request from POSTMAN, but we will send data using body in JSON format, and you can see we get the access token here.

    ![](/imgs/Screenshot%202023-10-09%20at%207.25.51‚ÄØAM.png)

    So, if we want to create a protcted route now, so that only an authenticated user can view this. For this purpose we will use a direct decorator. And, this is how we can have a restricted route.

    `views.py` - `api` app

    ```python
    from django.shortcuts import render
    from django.http import JsonResponse
    from rest_framework.decorators import api_view, permission_classes
    from rest_framework.permissions import IsAuthenticated, IsAdminUser
    from rest_framework.response import Response
    from projects.models import Project
    from .serializers import ProjectSerializer

    # Create your views here.

    @api_view(['GET'])
    def getRoutes(request):
        routes = [
            {'GET':'/api/projects'},
            {'GET':'/api/projects/id'},
            
            {'POST':'/api/projects/id/vote'},
            {'POST':'/api/users/token'},
            {'POST':'/api/users/token/refresh'},
        ]
        return Response(routes)

    @api_view(['GET'])
    @permission_classes([IsAuthenticated])
    def getProjects(request):
        projects = Project.objects.all()
        serializer = ProjectSerializer(projects, many=True)
        return Response(serializer.data)

    @api_view(['GET'])
    def getProject(request,pk):
        project = Project.objects.get(id=pk)
        serializer = ProjectSerializer(project, many=False)
        return Response(serializer.data)
    ```

    And, now if you search `http://127.0.0.1:8000/api/projects/`, you would see something like this.

    ![](/imgs/Screenshot%202023-10-09%20at%207.36.07‚ÄØAM.png)

    So, this is where postman actually comes into play here. So, we can actually send a token with this route. So, again if we send a request from postman immediately, we get the same response.

    ![](/imgs/Screenshot%202023-10-09%20at%207.39.19‚ÄØAM.png)

    So, we first need to generate a user token, in order to access that. So, once we have generated that, it will be valid for the next 5 mins. Now, we move to the projects reques in postman and, add a `Authourization` Header along with the `Value`:`Bearer <token>`.

    ![](/imgs/Screenshot%202023-10-09%20at%207.42.50‚ÄØAM.png)

    So, after this we want to let's say know which user is requesting it, so we just add a statement request.user to be printed by views, and whenever, the request is made using the access token, we can get the user's detail trying to access all the projects as hsown below.

    ![](/imgs/Screenshot%202023-10-09%20at%207.49.23‚ÄØAM.png)

    Once, you are done, make the following edits to as shown below:

    `views.py` - `api` app

    ```python
    from django.shortcuts import render
    from django.http import JsonResponse
    from rest_framework.decorators import api_view, permission_classes
    from rest_framework.permissions import IsAuthenticated, IsAdminUser
    from rest_framework.response import Response
    from projects.models import Project
    from .serializers import ProjectSerializer

    # Create your views here.

    @api_view(['GET'])
    def getRoutes(request):
        routes = [
            {'GET':'/api/projects'},
            {'GET':'/api/projects/id'},
            
            {'POST':'/api/projects/id/vote'},
            {'POST':'/api/users/token'},
            {'POST':'/api/users/token/refresh'},
        ]
        return Response(routes)

    @api_view(['GET'])
    def getProjects(request):
        print("User: ",request.user)
        projects = Project.objects.all()
        serializer = ProjectSerializer(projects, many=True)
        return Response(serializer.data)

    @api_view(['GET'])
    def getProject(request,pk):
        project = Project.objects.get(id=pk)
        serializer = ProjectSerializer(project, many=False)
        return Response(serializer.data)
    ```

    And, everything should be fine and accessible without any token.

## Customizing Tokens

- So, make some changes to `settings.py` in your `project` folder.

    `settings.py` - `project` folder

    ```python
    """
    Django settings for test_project project.

    Generated by 'django-admin startproject' using Django 4.1.7.

    For more information on this file, see
    https://docs.djangoproject.com/en/4.1/topics/settings/

    For the full list of settings and their values, see
    https://docs.djangoproject.com/en/4.1/ref/settings/
    """

    from pathlib import Path
    from datetime import timedelta
    import os

    # Build paths inside the project like this: BASE_DIR / 'subdir'.
    BASE_DIR = Path(__file__).resolve().parent.parent


    # Quick-start development settings - unsuitable for production
    # See https://docs.djangoproject.com/en/4.1/howto/deployment/checklist/

    # SECURITY WARNING: keep the secret key used in production secret!
    SECRET_KEY = "django-insecure-j%6$9q#pw3cyqpsh=*lwpg6s-l23-)gk1wz3h-hbyk!muaivr_"

    # SECURITY WARNING: don't run with debug turned on in production!
    DEBUG = True

    ALLOWED_HOSTS = ['localhost','127.0.0.1']


    # Application definition

    INSTALLED_APPS = [
        "django.contrib.admin",
        "django.contrib.auth",
        "django.contrib.contenttypes",
        "django.contrib.sessions",
        "django.contrib.messages",
        "django.contrib.staticfiles",
        
        "projects.apps.ProjectsConfig",
        "users.apps.UsersConfig",
        'fontawesomefree',
        
        'rest_framework',
    ]

    REST_FRAMEWORK = {
        'DEFAULT_AUTHENTICATION_CLASSES': (
            'rest_framework_simplejwt.authentication.JWTAuthentication',
        )
    }

    SIMPLE_JWT = {
        "ACCESS_TOKEN_LIFETIME": timedelta(days=1),
        "REFRESH_TOKEN_LIFETIME": timedelta(days=1),
        "ROTATE_REFRESH_TOKENS": False,
        "BLACKLIST_AFTER_ROTATION": False,
        "UPDATE_LAST_LOGIN": False,

        "ALGORITHM": "HS256",
        "VERIFYING_KEY": "",
        "AUDIENCE": None,
        "ISSUER": None,
        "JSON_ENCODER": None,
        "JWK_URL": None,
        "LEEWAY": 0,

        "AUTH_HEADER_TYPES": ("Bearer",),
        "AUTH_HEADER_NAME": "HTTP_AUTHORIZATION",
        "USER_ID_FIELD": "id",
        "USER_ID_CLAIM": "user_id",
        "USER_AUTHENTICATION_RULE": "rest_framework_simplejwt.authentication.default_user_authentication_rule",

        "AUTH_TOKEN_CLASSES": ("rest_framework_simplejwt.tokens.AccessToken",),
        "TOKEN_TYPE_CLAIM": "token_type",
        "TOKEN_USER_CLASS": "rest_framework_simplejwt.models.TokenUser",

        "JTI_CLAIM": "jti",

        "SLIDING_TOKEN_REFRESH_EXP_CLAIM": "refresh_exp",
        "SLIDING_TOKEN_LIFETIME": timedelta(minutes=5),
        "SLIDING_TOKEN_REFRESH_LIFETIME": timedelta(days=1),

        "TOKEN_OBTAIN_SERIALIZER": "rest_framework_simplejwt.serializers.TokenObtainPairSerializer",
        "TOKEN_REFRESH_SERIALIZER": "rest_framework_simplejwt.serializers.TokenRefreshSerializer",
        "TOKEN_VERIFY_SERIALIZER": "rest_framework_simplejwt.serializers.TokenVerifySerializer",
        "TOKEN_BLACKLIST_SERIALIZER": "rest_framework_simplejwt.serializers.TokenBlacklistSerializer",
        "SLIDING_TOKEN_OBTAIN_SERIALIZER": "rest_framework_simplejwt.serializers.TokenObtainSlidingSerializer",
        "SLIDING_TOKEN_REFRESH_SERIALIZER": "rest_framework_simplejwt.serializers.TokenRefreshSlidingSerializer",
    }

    MIDDLEWARE = [
        "django.middleware.security.SecurityMiddleware",
        "django.contrib.sessions.middleware.SessionMiddleware",
        "django.middleware.common.CommonMiddleware",
        "django.middleware.csrf.CsrfViewMiddleware",
        "django.contrib.auth.middleware.AuthenticationMiddleware",
        "django.contrib.messages.middleware.MessageMiddleware",
        "django.middleware.clickjacking.XFrameOptionsMiddleware",
        "whitenoise.middleware.WhiteNoiseMiddleware", # Added by user.
    ]

    ROOT_URLCONF = "test_project.urls"

    TEMPLATES = [
        {
            "BACKEND": "django.template.backends.django.DjangoTemplates",
            "DIRS": [
                os.path.join(BASE_DIR,"templates"), # This let's Django know where our templates are.
            ],
            "APP_DIRS": True,
            "OPTIONS": {
                "context_processors": [
                    "django.template.context_processors.debug",
                    "django.template.context_processors.request",
                    "django.contrib.auth.context_processors.auth",
                    "django.contrib.messages.context_processors.messages",
                ],
            },
        },
    ]

    WSGI_APPLICATION = "test_project.wsgi.application"


    # Database
    # https://docs.djangoproject.com/en/4.1/ref/settings/#databases

    DATABASES = {
        "default": {
            "ENGINE": "django.db.backends.sqlite3",
            "NAME": BASE_DIR / "db.sqlite3",
        }
    }


    # Password validation
    # https://docs.djangoproject.com/en/4.1/ref/settings/#auth-password-validators

    AUTH_PASSWORD_VALIDATORS = [
        {
            "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
        },
        {
            "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
        },
        {
            "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
        },
        {
            "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
        },
    ]


    # Internationalization
    # https://docs.djangoproject.com/en/4.1/topics/i18n/

    LANGUAGE_CODE = "en-us"

    TIME_ZONE = "UTC"

    USE_I18N = True

    USE_TZ = True

    EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
    EMAIL_HOST = 'smtp.gmail.com'
    EMAIL_PORT = 587 # You can find it by googling "gmail PORT"
    EMAIL_USE_TLS = True
    EMAIL_HOST_USER = 'djangoproject296@gmail.com'
    EMAIL_HOST_PASSWORD = 'lityopearxagdlvw'

    # Static files (CSS, JavaScript, Images)
    # https://docs.djangoproject.com/en/4.1/howto/static-files/

    STATIC_URL = "/static/"
    MEDIA_URL = "/images/"

    STATICFILES_DIRS = [
        BASE_DIR / 'static'
    ]

    MEDIA_ROOT = os.path.join(BASE_DIR,"static/images")
    STATIC_ROOT = os.path.join(BASE_DIR,"staticfiles")

    # Default primary key field type
    # https://docs.djangoproject.com/en/4.1/ref/settings/#default-auto-field

    DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"
    ```
